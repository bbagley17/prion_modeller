//Prion Spread Simulator v1
//Bagley, B. ; Ender, L. ;
//
//This simulation is intended to model prion pathogenesis in a neuron population. Prions infect healthy proteins within
// a cell (converting said proteins into prions), and prions will additionally be exported and imported between each 
//cell and the extracellular medium (ECM). 
//
//This is a prototype with numerous approximations made for the sake of time and computational requirements.
//Later versions will replace these approximations with more precisely calculated values.
//Additional future features include factoring in potential transmission via tubules between adjacent neurons
//with the eventual goal of theoretically predicting which mechanism (vesicle excretion or spread via tubules)
//predominates in prion spread.
//
//

#include <iostream>
#include <iomanip>
#include <ctime>
#include <cstring>

using namespace std;

long double k[1000];
static  long double soln[2][10000][10000];
static int i;

void ECMupdate(long double& ECMprionCount, int tanknumber, long double cellVolume, long double ECMvolume)
{
	//constants to be determined
	long double k1 = 0.000000002;
	long double k2 = 0.000000002;
	//temporary value for Prion concentration outside cell
	long double tempECMprionConc;
	//updates prion flow in and out of cells, cell by cell
	for (int n = 0; n < tanknumber; n++)
	{
		tempECMprionConc = ECMprionCount / ECMvolume;
		if (soln[0][n][i]>1000)
			ECMprionCount = ECMprionCount + k1*((soln[0][n][i] / cellVolume) - tempECMprionConc);
		//The if statements are intended to prevent division by zero and other physically inaccurate operations
		if (ECMprionCount > (10 * tanknumber))
			soln[0][n][i] = soln[0][n][i] + k2*(tempECMprionConc - (soln[0][n][i] / cellVolume));
		//Accounting for synthesis of new proteins back to normal levels. Later versions will feature more precise
		// calculation for this factor.
		soln[1][n][i + 1] = 2000000;
	}
}

void evalF(long double y1, long double y2, double dt, long double cellVolume, long double ECMvolume)
{
	//Stat mech constant that still needs defining
	long double c1 = 0.00000000000000002;
		k[j] = dt*(c1 * y1 * y2 / (cellVolume*cellVolume)); // Add ODEs here
}

void rungeK(long double tBeg, long double tEnd, int numIter, long double cellVolume,
	long double ECMvolume, long double ECMprionCount, int tanknumber)
{
	int o = tanknumber; // Determine vertical length of initial conditions (# of ODEs to solve)
	long double k1[1000], k2[1000], k3[1000], k4[1000];
	long double dt = (tEnd - tBeg) / numIter; // Determine dt based on start time, end time, and number of iterations desired **Does the fact that these are ints break anything?***
											  //double soln[1000][1000]; // Initialize solution matrix
	long double inter1;
	long double inter2;   // Declare temporary array used for calclulating various k's.

	for (int i = 0; i < numIter; i++) {
		for (int j = 0; j < o; j++)
		{
			inter1 = soln[0][j][i];
			inter2 = soln[1][j][i];
			k1j] = evalF(inter1, inter2, dt, cellVolume, ECMvolume);
		}
		evalF(inter1, inter2, dt, cellVolume, ECMvolume);

		for (int m = 0; m < o; m++)
			k1[m] = k[m];
		for (int j = 0; j < o; j++)
		{
			inter1[j] = soln[0][j][i];
			inter2[j] = soln[1][j][i];
		}
		for (int l = 0; l < o; l++)
			inter1[l] += .5*k1[l];
		evalF(inter1, inter2, dt, cellVolume, ECMvolume);
		for (int m = 0; m < o; m++)
			k2[m] = k[m];
		for (int j = 0; j < o; j++)
		{
			inter1[j] = soln[0][j][i];
			inter2[j] = soln[1][j][i];
		}
		for (int l = 0; l < o; l++)
			inter1[l] += .5*k2[l];
		evalF(inter1, inter2, dt, cellVolume, ECMvolume);
		for (int m = 0; m < o; m++)
			k3[m] = k[m];
		for (int j = 0; j < o; j++)
		{
			inter1[j] = soln[0][j][i];
			inter2[j] = soln[1][j][i];
		}
		for (int l = 0; l < o; l++)
			inter1[l] += k3[l];
		evalF(inter1, inter2, dt, cellVolume, ECMvolume);
		for (int m = 0; m < o; m++)
			k4[m] = k[m];
		for (int j = 0; j < o; j++)
			soln[0][j][i + 1] = soln[0][j][i] + (k1[j] + 2 * k2[j] + 2 * k3[j] + k4[j]) / 6;
		cout << "Timestep " << i << " complete." << endl;
		ECMupdate(ECMprionCount, tanknumber, cellVolume, ECMvolume);
	}
	//Outputting data
	for (int i = 0; i < tanknumber; i++)
	{
		cout << "Evolution of Tank " << i + 1 << ":";
		for (int j = 0; j <= numIter; j++)
		{
			cout << soln[0][i][j] << " ";
		}
		cout << endl << endl;
	}
}

int main()
{
	i = 0;
	int tanknumber;
	cout << "Please enter the number of cells to be modeled: ";
	cin >> tanknumber;
	cout << endl;

	//Volume of cell (NOTE: volume is in liters)
	long double cellVolume = 0.000000000002;


	//Creating time values
	const  long double timeStart = 0;
	static  long double timeStop = 0;
	int numIter;

	cout << "Please enter the stop time for the simulation (in [unit to be determined]):";
	cin >> timeStop;
	cout << endl << "Please enter the number of timesteps for the simulation (higher numbers yield higher accuracy, but increase computational time required):";
	cin >> numIter;
	cout << endl;

	//Let's make the extracellular medium.
	long double ECMprionCount = 0;
	long double ECMvolume = tanknumber*cellVolume * 0.55;//Estimated ratio of ECM volume to cell volume provided by Dr. M. Sardinia


														 //Number of diseased proteins (prions) in each cell, and in the local extracellular medium.
														 // The first matrix of the soln tensor (3D matrix) will store prion numbers.
	soln[0][0][0] = 1;

	for (int n = 1; n < tanknumber; n++)
	{
		soln[0][n][0] = 0;
	}

	//Concentration of healthy proteins in each cell. 
	//Second matrix of soln tensor will store healthy protein numbers.
	for (int n = 0; n < tanknumber; n++)
	{
		soln[1][n][0] = 2000000;
		//Average number of an arbitrary signalling protein at any time in a cell is 2 million, so we'll use this value for 
		//the number of healthy proteins
	}


	//Current data on the subject is actually rather curious, in that entire cell cultures die en-masse almost simultaneously 
	//even though prion toxicity is time dependent. This suggests the prion spread may occur extremely rapidly. 

	for (int q = 0; q < 2; q++)
	{
		for (int n = 0; n < tanknumber; n++)
		{
			cout << soln[q][n][0] << " ";
		}
		cout << endl;
	}

	int keepgoing;
	cout << "Please take this opportunity to review the initial values. Enter 1 to continue the simulation:";
	cin >> keepgoing;
	cout << endl;

	if (keepgoing = 1)
		rungeK(timeStart, timeStop, numIter, cellVolume, ECMvolume, ECMprionCount, tanknumber);


	return 0;

}
