#include <iostream>
#include <iomanip>
#include <ctime>
#include <cstring>

using namespace std;

double k[1000];
static double storedCounts[1000][1000];

void ECMupdate(double& ECMprionCount, int tanknumber, double cellVolume, double ECMvolume)
{
	//constants to be determined
	double k1 = 2;
	double k2 = 2;
	//temporary value for Prion concentration outside cell
	double tempECMprionConc;
	//updates prion flow in and out of cells, cell by cell
	for (int n = 0; n < tanknumber; n++)
	{
		//The if statements are intended to prevent division by zero and other physically inaccurate operations
		if (ECMprionCount > (10 * tanknumber))
		{
			tempECMprionConc = ECMprionCount / ECMvolume;
			if (storedCounts[0][n] > 1000)
				ECMprionCount = ECMprionCount + k1*((storedCounts[0][n] / cellVolume) - tempECMprionConc);
			storedCounts[0][n] = storedCounts[0][n] + k2*(tempECMprionConc - (storedCounts[0][n] / cellVolume));
		}
		//Accounting for synthesis of new proteins back to normal levels. Later versions will feature more precise
		// calculation for this factor.
		storedCounts[1][n] = 2000000;
	}
}

void evalF(double y1[], double y2[],int o, double dt, double cellVolume, double ECMvolume)
{
	//Stat mech constant that still needs defining
	double c1 = 2;
	for (int j = 0; j < o; j++)
		k[j] = dt*(c1 * y1[j] * y2[j] / (cellVolume*cellVolume)); // Add ODEs here
}

void rungeK(double init[2][1000], double tBeg, double tEnd, int numIter, double cellVolume,
	double ECMvolume, double ECMprionCount, int tanknumber)
{
	double soln[2][1000][1000];
	int o = tanknumber; // Determine vertical length of initial conditions (# of ODEs to solve)
	double k1[1000], k2[1000], k3[1000], k4[1000];
	double dt = (tEnd - tBeg) / numIter; // Determine dt based on start time, end time, and number of iterations desired **Does the fact that these are ints break anything?***
										 //double soln[1000][1000]; // Initialize solution matrix
	double inter1[1000];
	double inter2[1000];   // Declare temporary array used for calclulating various k's.

	for (int d = 0; d < numIter; d++)
	{
		soln[0][d][0] = init[0][d]; // Load initial conditions into solution matrix
		soln[1][d][0] = init[1][d];
	}
	for (int i = 0; i < numIter; i++) { 
		for (int j = 0; j < o; j++)
		{
			inter1[j] = soln[0][j][i];
			inter2[j] = soln[1][j][i];
		}
		evalF(inter1, inter2, o , dt, cellVolume, ECMvolume);
		
		for (int m = 0; m < o; m++)
			k1[m] = k[m];
		for (int j = 0; j < o; j++)
		{
			inter1[j] = soln[0][j][i];
			inter2[j] = soln[1][j][i];
		}
		for (int l = 0; l < o; l++)
			inter1[l] += .5*k1[l];
		evalF(inter1, inter2, o, dt, cellVolume, ECMvolume);
		for (int m = 0; m < o; m++)
			k2[m] = k[m];
		for (int j = 0; j < o; j++)
		{
			inter1[j] = soln[0][j][i];
			inter2[j] = soln[1][j][i];
		}
		for (int l = 0; l < o; l++)
			inter1[l] += .5*k2[l];
		evalF(inter1, inter2, o, dt, cellVolume, ECMvolume);
		for (int m = 0; m < o; m++)
			k3[m] = k[m];
		for (int j = 0; j < o; j++)
		{
			inter1[j] = soln[0][j][i];
			inter2[j] = soln[1][j][i];
		}
		for (int l = 0; l < o; l++)
			inter1[l] += k3[l];
		evalF(inter1, inter2, o, dt, cellVolume, ECMvolume);
		for (int m = 0; m < o; m++)
			k4[m] = k[m];
		for (int j = 0; j < o; j++)
			soln[0][j][i + 1] = soln[0][j][i] + (k1[j] + 2 * k2[j] + 2 * k3[j] + k4[j]) / 6;
		cout << "Timestep " << i << " complete." << endl;
		ECMupdate(ECMprionCount, tanknumber, cellVolume, ECMvolume);

		//Something to set the first row of storedCounts as the latest column of the soln matrix
		for (int j = 0; j < tanknumber; j++)
		{
			storedCounts[0][0][j] = soln[0][j][numIter + 1];
			storedCounts[1][0][j] = soln[1][j][1];
		}
	}
	//Outputting data
	for (int i = 0; i < tanknumber; i++)
	{
		cout << "Evolution of Tank " << i + 1 << ":";
		for (int j = 0; j <= numIter; j++)
		{
			cout << soln[i][j] << " " << endl;
		}
		cout << endl << endl;
	}
}

int main()
{
	int tanknumber;
	cout << "Please enter the number of cells to be modeled: ";
	cin >> tanknumber;
	cout << endl;

	//Volume of cell (NOTE: volume is in liters)
	double cellVolume = 0.000000000002;

	/* Later version will hopefully use classes for cells.
	class Cell
	{
	public:
	//Number of prions (diseased proteins) in each cell.
	double prionCount;

	//Number of healthy proteins in each cell.
	double proteinCount;

	//Rate at which cells excrete prions. Dependent of prion concentration.
	double prionOutput;

	//Rate at which cells uptake prions from extracellular medium. Dependent on extracellular prion concentration.
	double prionInput;


	//Production of new, healthy proteins in a timestep, which may then be added to proteinCount before the next timestep.
	//The basic idea is that cells will try to maintain the initial number of proteins for standard function, so we just
	//add enough to get the healthy count back up to 2,000,000 healthy proteins of the relelvant type.
	//For initial version, this variable will not be used, as we're just going to update the healthy protein count back to 2mil
	//every timestep.
	//double newproteinCount

	double getPrionCount() { return prionCount };
	double getProteinCount() { return proteinCount };
	double getPrionOutput() { return prionOutput };
	double getPrionInput() { return prionInput };
	void resetProteinCount(double newProteinCount)
	{
	proteinCount = newProteinCount;
	}
	};
	*/


	//Creating time values
	const double timeStart = 0;
	static double timeStop = 0;
	double numIter;

	cout << "Please enter the stop time for the simulation (in [unit to be determined]):";
	cin >> timeStop;
	cout << endl << "Please enter the number of timesteps for the simulation (higher numbers yield higher accuracy, but increase computational time required):";
	cin >> numIter;
	cout << endl;


	/*string num;
	//string cellname;
	//Cell cell1(1, 2000000, 0, 0);
	for (cellnumber = 2; cellnumber < tanknumber; cellnumber++)
	{
	//Something to concatinate "cell" with the value of cellnumber
	cellname = "cell" + std::toString(cellnumber);
	Cell cellname(0.0, 2000000.0, 0.0, 0.0);
	}
	//And now we've made all the cells.
	*/




	//Let's make the extracellular medium.
	double ECMprionCount = 0;
	//Still need to estimate this:
	double ECMvolume = tanknumber*cellVolume * 0.55;//Estimated ratio of ECM volume to cell volume provided by Dr. M. Sardinia


													//Establishing variable arrays based on number of tanks input by user. Using arrays makes it scalable (obviously),
													// and should help simplify our later code

													//Concentration of diseased proteins (prions) in each cell, and in the local extracellular medium. Last value is for ECM.
	static double prionCount[1000];

	prionCount[0] = 1;

	for (int n = 1; n < tanknumber; n++)
	{
		prionCount[n] = 0;
	}

	//Concentration of healthy proteins in each cell.
	static double healthyProteinCount[1000];

	for (int n = 0; n < tanknumber; n++)
	{
		healthyProteinCount[n] = 2000000;
	}

	//Rate at which cells excrete prions, either through tubules to adjacent cells of via dispersal of vesicles into ECM.
	static double prionOutput[1000];
	//Rate at which cells uptake secreted prions.
	static double prionInput[1000];

	//
	//
	//Rate at which cells produce healthy proteins. Not used in current version
	//double proteinSynthesisRate[tanknumber];


	//Current data on the subject is actually rather curious, in that entire cell cultures die en-masse almost simultaneously 
	//even though prion toxicity is time dependent. This suggests the prion spread may occur extremely rapidly. 

	double init[2][1000];

	for (int n = 0; n < tanknumber; n++)
	{
		init[0][n] = prionCount[n];
		init[1][n] = healthyProteinCount[n];
	}

	for (int q = 0; q < 2; q++)
	{
		for (int n = 0; n < tanknumber; n++)
		{
			cout << init[q][n] << " ";
		}
		cout << endl;
	}

	int keepgoing = 0;
	cout << "Please take this opportunity to review the initial values. Enter 1 to continue the simulation:";
	cin >> keepgoing;
	cout << endl;

	for (int q = 0; q < 2; q++)
	{
		for (int n = 0; n < tanknumber; n++)
		{
			storedCounts[q][n] = init[q][n];
		}
		cout << endl;
	}

	if (keepgoing == 1)
		rungeK(init, timeStart, timeStop, numIter, cellVolume, ECMvolume, ECMprionCount, tanknumber);


	keepgoing = 0;

	cout << "Please review the final values:";
	cout << endl << "Please enter 1 to end the simulation:";
	cin >> keepgoing;


	if (keepgoing == 1)
		return 0;

}
