//Prion Spread Simulator v1
//Bagley, B. ; Ender, L. ;
//
//This simulation is intended to model prion pathogenesis in a neuron population. Prions infect healthy proteins within
// a cell (converting said proteins into prions), and prions will additionally be exported and imported between each 
//cell and the extracellular medium (ECM). 
//
//This is a prototype with numerous approximations made for the sake of time and computational requirements.
//Later versions will replace these approximations with more precisely calculated values.
//Additional future features include factoring in potential transmission via tubules between adjacent neurons
//with the eventual goal of theoretically predicting which mechanism (vesicle excretion or spread via tubules)
//predominates in prion spread.
//
//

#include <iostream>
#include <iomanip>
#include <ctime>
#include <cstring>

using namespace std;

long double k[1000];
static  long double storedCounts[2][10000][10000];
static int i;

void ECMupdate( long double& ECMprionCount, int tanknumber,  long double cellVolume,  long double ECMvolume)
{
	//constants to be determined
	 double k1 = 2;
	 double k2 = 2;
	//temporary value for Prion concentration outside cell
	 long double tempECMprionConc;
	//updates prion flow in and out of cells, cell by cell
	for (int n = 0; n < tanknumber; n++)
	{
		tempECMprionConc = ECMprionCount / ECMvolume;
		if (storedCounts[0][n][i]>1000)
			ECMprionCount = ECMprionCount + k1*((storedCounts[0][n][i] / cellVolume) - tempECMprionConc);
		//The if statements are intended to prevent division by zero and other physically inaccurate operations
		if (ECMprionCount > (10*tanknumber))
			storedCounts[0][n][i] = storedCounts[0][n][i] + k2*(tempECMprionConc - (storedCounts[0][n][i] / cellVolume));
		//Accounting for synthesis of new proteins back to normal levels. Later versions will feature more precise
		// calculation for this factor.
		storedCounts[1][n][i+1] = 2000000;
	}
}

void evalF(long double y1[], long double y2[], int o, double dt, long double cellVolume, long double ECMvolume)
{
	//Stat mech constant that still needs defining
	double c1 = 2;
	for (int j = 0; j < o; j++)
		k[j] = dt*(c1 * y1[j] * y2[j] / (cellVolume*cellVolume)); // Add ODEs here
}

void rungeK(long double init[2][1000], long double tBeg, long double tEnd, int numIter, long double cellVolume,
	long double ECMvolume, long double ECMprionCount, int tanknumber)
{
	double soln[2][1000][1000];
	int o = tanknumber; // Determine vertical length of initial conditions (# of ODEs to solve)
	long double k1[1000], k2[1000], k3[1000], k4[1000];
	long double dt = (tEnd - tBeg) / numIter; // Determine dt based on start time, end time, and number of iterations desired **Does the fact that these are ints break anything?***
										 //double soln[1000][1000]; // Initialize solution matrix
	long double inter1[1000];
	long double inter2[1000];   // Declare temporary array used for calclulating various k's.

	for (int d = 0; d < numIter; d++)
	{
		soln[0][d][0] = init[0][d]; // Load initial conditions into solution matrix
		soln[1][d][0] = init[1][d];
	}
	for (int i = 0; i < numIter; i++) {
		for (int j = 0; j < o; j++)
		{
			inter1[j] = soln[0][j][i];
			inter2[j] = soln[1][j][i];
		}
		evalF(inter1, inter2, o, dt, cellVolume, ECMvolume);

		for (int m = 0; m < o; m++)
			k1[m] = k[m];
		for (int j = 0; j < o; j++)
		{
			inter1[j] = soln[0][j][i];
			inter2[j] = soln[1][j][i];
		}
		for (int l = 0; l < o; l++)
			inter1[l] += .5*k1[l];
		evalF(inter1, inter2, o, dt, cellVolume, ECMvolume);
		for (int m = 0; m < o; m++)
			k2[m] = k[m];
		for (int j = 0; j < o; j++)
		{
			inter1[j] = soln[0][j][i];
			inter2[j] = soln[1][j][i];
		}
		for (int l = 0; l < o; l++)
			inter1[l] += .5*k2[l];
		evalF(inter1, inter2, o, dt, cellVolume, ECMvolume);
		for (int m = 0; m < o; m++)
			k3[m] = k[m];
		for (int j = 0; j < o; j++)
		{
			inter1[j] = soln[0][j][i];
			inter2[j] = soln[1][j][i];
		}
		for (int l = 0; l < o; l++)
			inter1[l] += k3[l];
		evalF(inter1, inter2, o, dt, cellVolume, ECMvolume);
		for (int m = 0; m < o; m++)
			k4[m] = k[m];
		for (int j = 0; j < o; j++)
			soln[0][j][i + 1] = soln[0][j][i] + (k1[j] + 2 * k2[j] + 2 * k3[j] + k4[j]) / 6;
		cout << "Timestep " << i << " complete." << endl;
		ECMupdate(ECMprionCount, tanknumber, cellVolume, ECMvolume);

		//Something to set the first row of storedCounts as the latest column of the soln matrix
		for (int j = 0; j < tanknumber; j++)
		{
			storedCounts[0][0][j] = soln[0][j][numIter + 1];
			storedCounts[1][0][j] = soln[1][j][1];
		}
	}
	//Outputting data
	for (int i = 0; i < tanknumber; i++)
	{
		cout << "Evolution of Tank " << i + 1 << ":";
		for (int j = 0; j <= numIter; j++)
		{
			cout << soln[i][j] << " " << endl;
		}
		cout << endl << endl;
	}
}

int main()
{
	i = 0;
	int tanknumber;
	cout << "Please enter the number of cells to be modeled: ";
	cin >> tanknumber;
	cout << endl;

	//Volume of cell (NOTE: volume is in liters)
	 long double cellVolume = 0.000000000002;

	/* Later version will hopefully use classes for cells.
	class Cell
	{
	public:
	//Number of prions (diseased proteins) in each cell.
	 long double prionCount;

	//Number of healthy proteins in each cell.
	 long double proteinCount;

	//Rate at which cells excrete prions. Dependent of prion concentration.
	 long double prionOutput;

	//Rate at which cells uptake prions from extracellular medium. Dependent on extracellular prion concentration.
	 long double prionInput;


	//Production of new, healthy proteins in a timestep, which may then be added to proteinCount before the next timestep.
	//The basic idea is that cells will try to maintain the initial number of proteins for standard function, so we just
	//add enough to get the healthy count back up to 2,000,000 healthy proteins of the relelvant type.
	//For initial version, this variable will not be used, as we're just going to update the healthy protein count back to 2mil
	//every timestep.
	// long double newproteinCount

	 long double getPrionCount() { return prionCount };
	 long double getProteinCount() { return proteinCount };
	 long double getPrionOutput() { return prionOutput };
	 long double getPrionInput() { return prionInput };
	void resetProteinCount( long double newProteinCount)
	{
	proteinCount = newProteinCount;
	}
	};
	*/


	//Creating time values
	const  long double timeStart = 0;
	static  long double timeStop = 0;
	int numIter;

	cout << "Please enter the stop time for the simulation (in [unit to be determined]):";
	cin >> timeStop;
	cout << endl << "Please enter the number of timesteps for the simulation (higher numbers yield higher accuracy, but increase computational time required):";
	cin >> numIter;
	cout << endl;


	/*string num;
	//string cellname;
	//Cell cell1(1, 2000000, 0, 0);
	for (cellnumber = 2; cellnumber < tanknumber; cellnumber++)
	{
	//Something to concatinate "cell" with the value of cellnumber
	cellname = "cell" + std::toString(cellnumber);
	Cell cellname(0.0, 2000000.0, 0.0, 0.0);
	}
	//And now we've made all the cells.
	*/




	//Let's make the extracellular medium.
	 long double ECMprionCount = 0;
	//Still need to estimate this:
	 long double ECMvolume = tanknumber*cellVolume * 0.55;//Estimated ratio of ECM volume to cell volume provided by Dr. M. Sardinia


													//Establishing variable arrays based on number of tanks input by user. Using arrays makes it scalable (obviously),
													// and should help simplify our later code

													//Concentration of diseased proteins (prions) in each cell, and in the local extracellular medium. Last value is for ECM.
	static  long double prionCount[1000];

	prionCount[0] = 1;

	for (int n = 1; n < tanknumber; n++)
	{
		prionCount[n] = 0;
	}

	//Concentration of healthy proteins in each cell.
	static  long double healthyProteinCount[1000];

	for (int n = 0; n < tanknumber; n++)
	{
		healthyProteinCount[n] = 2000000;
	}

	//Rate at which cells excrete prions, either through tubules to adjacent cells of via dispersal of vesicles into ECM.
	static  long double prionOutput[1000];
	//Rate at which cells uptake secreted prions.
	static  long double prionInput[1000];

	//
	//
	//Rate at which cells produce healthy proteins. Not used in current version
	// long double proteinSynthesisRate[tanknumber];


	//Current data on the subject is actually rather curious, in that entire cell cultures die en-masse almost simultaneously 
	//even though prion toxicity is time dependent. This suggests the prion spread may occur extremely rapidly. 

	 long double init[2][1000];

	for (int n = 0; n < tanknumber; n++)
	{
		init[0][n] = prionCount[n];
		init[1][n] = healthyProteinCount[n];
	}

	for (int q = 0; q < 2; q++)
	{
		for (int n = 0; n < tanknumber; n++)
		{
			cout << init[q][n] << " ";
		}
		cout << endl;
	}

	int keepgoing;
	cout << "Please take this opportunity to review the initial values. Enter 1 to continue the simulation:";
	cin >> keepgoing;
	cout << endl;

	if (keepgoing =1)
		rungeK(init, timeStart, timeStop, numIter, cellVolume, ECMvolume, ECMprionCount, tanknumber);


	return 0;

}
