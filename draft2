#include <iostream>
#include <iomanip>
#include <ctime>
#include <cstring>

using namespace std;

double k[3];
static double soln[1000][1000];

void ECMupdate(double& ECMprionCount, int tanknumber, double cellVolume, double ECMvolume)
{
	//constant to be determined
	double k1;
	double k2;
	//temp value for Prion concentration outside cell
	double tempECMprionConc;
	//updates prion flow in and out of cells, cell by cell
	for (int n = 0; n < tanknumber;)
	{
		//Need to fix these equations. I goofed. 
		tempECMprionConc = ECMprionCount / ECMvolume;
		ECMprionCount = ECMprionCount + k1*((soln[1][n] / cellVolume) - (ECMprionCount / ECMvolume));
		soln[1][n] = soln[1][n] + k2*(tempECMprionConc - (soln[1][n] / cellVolume));
	}

}

void evalF(double y[], double dt, double cellVolume, double ECMvolume)
{
	double k[3];
	//Stat mech constant that still needs defining
	double c1;
	k[0] = dt*(c1 * y[0] * y[1] / (cellVolume*cellVolume)); // Add ODEs here
															//k[1] = dt*(3 * y[1] + 5 * y[2]);
															//k[2] = dt*(3 * y[0] + 5 * y[2]);
}

void rungeK(double init[2][1000], double tBeg, double tEnd, const int numIter, const double cellVolume, const double ECMvolume)
{
	int o = sizeof(init) / sizeof(*init); // Determine vertical length of initial conditions (# of ODEs to solve)
	double k1[1000], k2[1000], k3[1000], k4[1000];
	double dt = (tEnd - tBeg) / numIter; // Determine dt based on start time, end time, and number of iterations desired **Does the fact that these are ints break anything?***
										 //double soln[1000][1000]; // Initialize solution matrix
	double inter[1000]; // Declare temporary array used for calclulating various k's.
	for (int d = 0; d < o; d++)
		soln[d][0] = init[0][d]; // Load initial conditions into solution matrix

	for (int i = 0; i < numIter; i++) { // Runga kutta doing its magic. I've checked its output with some matlab code I found and it's working perfectly.
		for (int j = 0; j < 3; j++)
			inter[j] = soln[j][i];
		evalF(inter, dt, cellVolume, ECMvolume);
		for (int m = 0; m < o; m++)
			k1[m] = k[m];
		for (int j = 0; j < o; j++)
			inter[j] = soln[j][i];
		for (int l = 0; l < o; l++)
			inter[l] += .5*k1[l];
		evalF(inter, dt, cellVolume, ECMvolume);
		for (int m = 0; m < o; m++)
			k2[m] = k[m];
		for (int j = 0; j < o; j++)
			inter[j] = soln[j][i];
		for (int l = 0; l < o; l++)
			inter[l] += .5*k2[l];
		evalF(inter, dt, cellVolume, ECMvolume);
		for (int m = 0; m < o; m++)
			k3[m] = k[m];
		for (int j = 0; j < o; j++)
			inter[j] = soln[j][i];
		for (int l = 0; l < o; l++)
			inter[l] += k3[l];
		evalF(inter, dt, cellVolume, ECMvolume);
		for (int m = 0; m < o; m++)
			k4[m] = k[m];
		for (int j = 0; j < o; j++)
			soln[j][i + 1] = soln[j][i] + (k1[j] + 2 * k2[j] + 2 * k3[j] + k4[j]) / 6;
	}
	//Could you add some loop that will output all the prion counts? Answer: yes!
	for (int i = 0; i < o; i++)
	{
		for (int j = 0; j <= numIter; j++)
			cout << soln[j][i] << " ";
		cout << endl;
	}
}

int main()
{
	int tanknumber;
	cout << "Please enter the number of tanks used in this problem: ";
	cin >> tanknumber;
	cout << endl;
	int stoptime;
	cout << "Please enter the number of (insert time unit) you would like to simulate: ";
	cin >> stoptime;
	cout << endl;

	//Volume of cell (NOTE: volume is in liters)
	double cellVolume = 0.000000000002;

	/* Later version will hopefully use classes for cells.
	class Cell
	{
	public:
	//Number of prions (diseased proteins) in each cell.
	double prionCount;

	//Number of healthy proteins in each cell.
	double proteinCount;

	//Rate at which cells excrete prions. Dependent of prion concentration.
	double prionOutput;

	//Rate at which cells uptake prions from extracellular medium. Dependent on extracellular prion concentration.
	double prionInput;


	//Production of new, healthy proteins in a timestep, which may then be added to proteinCount before the next timestep.
	//The basic idea is that cells will try to maintain the initial number of proteins for standard function, so we just
	//add enough to get the healthy count back up to 2,000,000 healthy proteins of the relelvant type.
	//For initial version, this variable will not be used, as we're just going to update the healthy protein count back to 2mil
	//every timestep.
	//double newproteinCount

	double getPrionCount() { return prionCount };
	double getProteinCount() { return proteinCount };
	double getPrionOutput() { return prionOutput };
	double getPrionInput() { return prionInput };
	void resetProteinCount(double newProteinCount)
	{
	proteinCount = newProteinCount;
	}
	};
	*/


	//Creating time values
	const double timeStart = 0;
	static double timeStop = 0;
	int timeStep;

	cout << "Please enter the stop time for the simulation (in [unit to be determined]):";
	cin >> timeStop;
	cout << endl << "Please enter the timestep (in [insert units]):";
	cin >> timeStep;
	cout << endl;


	/*string num;
	//string cellname;
	//Cell cell1(1, 2000000, 0, 0);
	for (cellnumber = 2; cellnumber < tanknumber; cellnumber++)
	{
	//Something to concatinate "cell" with the value of cellnumber
	cellname = "cell" + std::toString(cellnumber);
	Cell cellname(0.0, 2000000.0, 0.0, 0.0);
	}
	//And now we've made all the cells.
	*/




	//Let's make the extracellular medium.
	double ECMprionCount = 0;
	//Still need to estimate this:
	double ECMvolume = tanknumber*cellVolume * 2;//Ask Dr. Sardinia for a good ratio between the number of neurons in a cell population and the volume of the ECM containing them




												 //Establishing variable arrays based on number of tanks input by user. Using arrays makes it scalable (obviously),
												 // and should help simplify our later code

												 //Concentration of diseased proteins (prions) in each cell, and in the local extracellular medium. Last value is for ECM.
	static double prionCount[1000];

	prionCount[0] = 1;

	for (int n = 1; n < tanknumber; n++)
	{
		prionCount[n] = 0;
	}

	//Concentration of healthy proteins in each cell.
	static double healthyProteinCount[1000];

	for (int n = 0; n < tanknumber; n++)
	{
		healthyProteinCount[n] = 2000000;
	}

	//Rate at which cells excrete prions, either through tubules to adjacent cells of via dispersal of vesicles into ECM.
	static double prionOutput[1000];
	//Rate at which cells uptake secreted prions.
	static double prionInput[1000];

	//
	//
	//Rate at which cells produce healthy proteins. Not used in current version
	//double proteinSynthesisRate[tanknumber];

	//The last value for prionConc will be the concentration in the medium via which material spreads from "tank" to "tank".

	//Current data on the subject is actually rather curious, in that entire cell cultures die en-masse almost simultaneously even though prion toxicity
	// is time dependent. This suggests the prion spread may occur immensely rapidly. 


	for (int n = 0; n < tanknumber; n++)
	{

		soln[1][n] = prionCount[n];
		soln[2][n] = healthyProteinCount[n];

	}


	//Loops which call relevent functions to update all arrays, cycling through the values of each array cell by cell.
	for (double time = 0; time <= timeStop; time = time + timeStep)
	{
		for (int n = 0; n < tanknumber; n++)
		{
			rungeK(soln, timeStart, timeStop, timeStep, cellVolume, ECMvolume);
		}
		//Something to add all exported prions to the concentration in the extracellular medium, and subtract all prions cells have uptaken
		ECMupdate(ECMprionCount, tanknumber, cellVolume, ECMvolume);

		for (int n = 0; n < tanknumber; n++)
		{
			//Accounting for synthesis of new healthy proteins (basically the cell replenishes them).
			healthyProteinCount[n] = 2000000;
		}
	}
}
